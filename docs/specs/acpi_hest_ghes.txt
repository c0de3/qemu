APEI tables generating and CPER record
=============================

Copyright (C) 2017 HuaWei Corporation.

Design Details:
-------------------

       etc/acpi/tables                                 etc/hardware_errors
    ====================                      ==========================================
+ +--------------------------+            +-----------------------+
| | HEST                     |            |    address            |            +--------------+
| +--------------------------+            |    registers          |            | Error Status |
| | GHES1                    |            | +---------------------+            | Data Block 1 |
| +--------------------------+ +--------->| |error_block_address1 |----------->| +------------+
| | .................        | |          | +---------------------+            | |  CPER      |
| | error_status_address-----+-+ +------->| |error_block_address2 |--------+   | |  CPER      |
| | .................        |   |        | +---------------------+        |   | |  ....      |
| | read_ack_register--------+-+ |        | |    ..............   |        |   | |  CPER      |
| | read_ack_preserve        | | |        +-----------------------+        |   | +------------+
| | read_ack_write           | | | +----->| |error_block_addressN |------+ |   | Error Status |
+ +--------------------------+ | | |      | +---------------------+      | |   | Data Block 2 |
| | GHES2                    | +-+-+----->| |read_ack_register1   |      | +-->| +------------+
+ +--------------------------+   | |      | +---------------------+      |     | |  CPER      |
| | .................        |   | | +--->| |read_ack_register2   |      |     | |  CPER      |
| | error_status_address-----+---+ | |    | +---------------------+      |     | |  ....      |
| | .................        |     | |    | |  .............      |      |     | |  CPER      |
| | read_ack_register--------+-----+-+    | +---------------------+      |     +-+------------+
| | read_ack_preserve        |     |   +->| |read_ack_registerN   |      |     | |..........  |
| | read_ack_write           |     |   |  | +---------------------+      |     | +------------+
+ +--------------------------|     |   |                                 |     | Error Status |
| | ...............          |     |   |                                 |     | Data Block N |
+ +--------------------------+     |   |                                 +---->| +------------+
| | GHESN                    |     |   |                                       | |  CPER      |
+ +--------------------------+     |   |                                       | |  CPER      |
| | .................        |     |   |                                       | |  ....      |
| | error_status_address-----+-----+   |                                       | |  CPER      |
| | .................        |         |                                       +-+------------+
| | read_ack_register--------+---------+
| | read_ack_preserve        |
| | read_ack_write           |
+ +--------------------------+

(1) QEMU generates the ACPI HEST table. This table goes in the current
    "etc/acpi/tables" fw_cfg blob. Each error source has different
    notification type.

(2) A new fw_cfg blob called "etc/hardware_errors" is introduced. QEMU
    also need to populate this blob. The "etc/hardwre_errors" fw_cfg blob
    contains one address registers table and one Error Status Data Block
    table, all of which are pre-allocated.

(3) The address registers table contains N Error Block Address entries
    and N Read Ack Address entries, the size for each entry is 8-byte.
    The Error Status Data Block table contains N Error Status Data Block
    entries, the size for each entry is 4096(0x1000) bytes. The total size
    for "etc/hardware_errors" fw_cfg blob is (N * 8 * 2 + N * 4096) bytes.

(4) QEMU generates the ACPI linker/loader script for the firmware

(4a) The HEST table is part of "etc/acpi/tables", the firmware already
    allocates the memory for it, because QEMU already generates an ALLOCATE
    linker/loader command for it

(4b) QEMU creates another ALLOCATE command for the "etc/hardware_errors"
    blob. The firmware allocates memory for this blob and downloads it.

(5) QEMU generates N ADD_POINTER commands, which patch address in the
    "error_status_address" fields of the HEST table with a pointer to the
    corresponding "address registers" in the downloaded "etc/hardware_errors"
    blob.

(6) QEMU generates N ADD_POINTER commands, which patch address in the
    "read_ack_register" fields of the HEST table with a pointer to the
    corresponding "address registers" in the downloaded "etc/hardware_errors" blob.

(7) QEMU generates N ADD_POINTER commands for the firmware, which patch
    address in the " error_block_address" fields with a pointer to the
    respective "Error Status Data Block" in the downloaded "etc/hardware_errors"
    blob.

(8) QEMU Defines a third and write-only fw_cfg blob which is called
    "etc/hardware_errors_addr". Through that blob, the firmware can send back
    the guest-side allocation addresses to QEMU. The "etc/hardware_errors_addr"
    blob contains a 8-byte entry. QEMU generates a single WRITE_POINTER commands
    for the firmware, the firmware will write back the start address of
    "etc/hardware_errors" blob to fw_cfg file "etc/hardware_errors_addr". Then
    Qemu will know the Error Status Data Block for every error source. Each of
    Error Status Data Block has fixed size which is 4096(0x1000).

(9) When QEMU gets SIGBUS from the kernel, QEMU formats the CPER right into
    guest memory, and then injects whatever interrupt (or assert whatever GPIO line)
    as a notification which is necessary for notifying the guest.

(10) This notification (in virtual hardware) will be handled by guest kernel,
    guest APEI driver will read the CPER which is recorded by QEMU and do the
    recovery.
