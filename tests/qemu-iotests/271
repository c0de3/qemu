#!/bin/bash
#
# Test qcow2 images with extended L2 entries
#
# Copyright (C) 2019-2020 Igalia, S.L.
# Author: Alberto Garcia <berto@igalia.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# creator
owner=berto@igalia.com

seq="$(basename $0)"
echo "QA output created by $seq"

here="$PWD"
status=1	# failure is the default!

_cleanup()
{
	_cleanup_test_img
        rm -f "$TEST_IMG.raw"
        rm -f "$TEST_IMG.backing"
}
trap "_cleanup; exit \$status" 0 1 2 3 15

# get standard environment, filters and checks
. ./common.rc
. ./common.filter

_supported_fmt qcow2
_supported_proto file nfs
_supported_os Linux

IMGOPTS="extended_l2=on"
l2_offset=262144 # 0x40000

_verify_img()
{
    $QEMU_IMG compare "$TEST_IMG" "$TEST_IMG.raw" | grep -v 'Images are identical'
    $QEMU_IMG check "$TEST_IMG" | _filter_qemu_img_check | \
        grep -v 'No errors were found on the image'
}

# Compare the bitmap of an extended L2 entry against an expected value
_verify_l2_bitmap()
{
    entry_no="$1"        # L2 entry number, starting from 0
    expected_alloc="$2"  # Space-separated list of allocated subcluster indexes
    expected_zero="$3"   # Space-separated list of zero subcluster indexes

    offset=$(($l2_offset + $entry_no * 16))
    entry=`peek_file_be "$TEST_IMG" $offset 8`
    offset=$(($offset + 8))
    bitmap=`peek_file_be "$TEST_IMG" $offset 8`

    expected_bitmap=0
    for bit in $expected_alloc; do
        expected_bitmap=$(($expected_bitmap | (1 << $bit)))
    done
    for bit in $expected_zero; do
        expected_bitmap=$(($expected_bitmap | (1 << (32 + $bit))))
    done
    expected_bitmap=`printf "%llu" $expected_bitmap`

    printf "L2 entry #%d: 0x%016lx %016lx\n" "$entry_no" "$entry" "$bitmap"
    if [ "$bitmap" != "$expected_bitmap" ]; then
        printf "ERROR: expecting bitmap       0x%016lx\n" "$expected_bitmap"
    fi
}

_test_write()
{
    cmd="$1"
    alloc_bitmap="$2"
    zero_bitmap="$3"
    l2_entry_idx="$4"
    [ -n "$l2_entry_idx" ] || l2_entry_idx=0
    raw_cmd=`echo $cmd | sed s/-c//` # Raw images don't support -c
    echo "$cmd"
    $QEMU_IO -c "$cmd" "$TEST_IMG" | _filter_qemu_io
    $QEMU_IO -c "$raw_cmd" -f raw "$TEST_IMG.raw" | _filter_qemu_io
    _verify_img
    _verify_l2_bitmap "$l2_entry_idx" "$alloc_bitmap" "$zero_bitmap"
}

_reset_img()
{
    $QEMU_IMG create -f raw "$TEST_IMG.raw" 1M | _filter_img_create
    if [ "$use_backing_file" = "yes" ]; then
        $QEMU_IMG create -f raw "$TEST_IMG.backing" 1M | _filter_img_create
        $QEMU_IO -c 'write -q -P 0xFF 0 1M' -f raw "$TEST_IMG.backing" | _filter_qemu_io
        $QEMU_IO -c 'write -q -P 0xFF 0 1M' -f raw "$TEST_IMG.raw" | _filter_qemu_io
        _make_test_img -b "$TEST_IMG.backing" 1M
    else
        _make_test_img 1M
    fi
}

# Test that writing to an image with subclusters produces the expected
# results, in images with and without backing files
for use_backing_file in yes no; do
    echo
    echo "### Standard write tests (backing file: $use_backing_file) ###"
    echo
    _reset_img
    ### Write subcluster #0 (beginning of subcluster) ###
    alloc="0"; zero=""
    _test_write 'write -q -P 1 0 1k' "$alloc" "$zero"

    ### Write subcluster #1 (middle of subcluster) ###
    alloc="0 1"; zero=""
    _test_write 'write -q -P 2 3k 512' "$alloc" "$zero"

    ### Write subcluster #2 (end of subcluster) ###
    alloc="0 1 2"; zero=""
    _test_write 'write -q -P 3 5k 1k' "$alloc" "$zero"

    ### Write subcluster #3 (full subcluster) ###
    alloc="0 1 2 3"; zero=""
    _test_write 'write -q -P 4 6k 2k' "$alloc" "$zero"

    ### Write subclusters #4-6 (full subclusters) ###
    alloc="`seq 0 6`"; zero=""
    _test_write 'write -q -P 5 8k 6k' "$alloc" "$zero"

    ### Write subclusters #7-9 (partial subclusters) ###
    alloc="`seq 0 9`"; zero=""
    _test_write 'write -q -P 6 15k 4k' "$alloc" "$zero"

    ### Write subcluster #16 (partial subcluster) ###
    alloc="`seq 0 9` 16"; zero=""
    _test_write 'write -q -P 7 32k 1k' "$alloc" "$zero"

    ### Write subcluster #31-#34 (cluster overlap) ###
    alloc="`seq 0 9` 16 31"; zero=""
    _test_write 'write -q -P 8 63k 4k' "$alloc" "$zero"
    alloc="0 1" ; zero=""
    _verify_l2_bitmap 1 "$alloc" "$zero"

    ### Zero subcluster #1 (TODO: use the "all zeros" bit)
    alloc="`seq 0 9` 16 31"; zero=""
    _test_write 'write -q -z 2k 2k' "$alloc" "$zero"

    ### Zero cluster #0
    alloc=""; zero="`seq 0 31`"
    _test_write 'write -q -z 0 64k' "$alloc" "$zero"

    ### Fill cluster #0 with data
    alloc="`seq 0 31`"; zero=""
    _test_write 'write -q -P 9 0 64k' "$alloc" "$zero"

    ### Zero and unmap half of cluster #0 (this won't unmap it)
    alloc="`seq 0 31`"; zero=""
    _test_write 'write -q -z -u 0 32k' "$alloc" "$zero"

    ### Zero and unmap cluster #0
    alloc=""; zero="`seq 0 31`"
    _test_write 'write -q -z -u 0 64k' "$alloc" "$zero"

    ### Write subcluster #1 (middle of subcluster)
    alloc="1"; zero="0 `seq 2 31`"
    _test_write 'write -q -P 10 3k 512' "$alloc" "$zero"

    ### Fill cluster #0 with data
    alloc="`seq 0 31`"; zero=""
    _test_write 'write -q -P 11 0 64k' "$alloc" "$zero"

    ### Discard cluster #0
    alloc=""; zero="`seq 0 31`"
    _test_write 'discard -q 0 64k' "$alloc" "$zero"

    ### Write compressed data to cluster #0
    alloc=""; zero=""
    _test_write 'write -q -c -P 12 0 64k' "$alloc" "$zero"

    ### Write subcluster #2 (middle of subcluster)
    alloc="`seq 0 31`"; zero=""
    _test_write 'write -q -P 13 3k 512' "$alloc" "$zero"

    ### Zeroize an unallocated cluster (#2)
    alloc=""; zero="`seq 0 31`"
    _test_write 'write -q -z 128k 64k' "$alloc" "$zero" 2

    ### Partially zeroize an unallocated cluster (#3)
    if [ "$use_backing_file" = "yes" ]; then
        alloc="`seq 0 15`"; zero=""
    else
        alloc=""; zero="`seq 0 31`"
    fi
    _test_write 'write -q -z 192k 32k' "$alloc" "$zero" 3
done

for use_backing_file in yes no; do
    echo
    echo "### Discarding clusters with non-zero bitmaps (backing file: $use_backing_file) ###"
    echo
    if [ "$use_backing_file" = "yes" ]; then
        _make_test_img -b "$TEST_IMG.backing" 1M
    else
        _make_test_img 1M
    fi
    # Write clusters #0-#2 and then discard them
    $QEMU_IO -c 'write -q 0 128k' "$TEST_IMG"
    $QEMU_IO -c 'discard -q 0 128k' "$TEST_IMG"
    # 'qemu-io discard' doesn't do a full discard, it zeroizes the
    # cluster, so both clusters have all zero bits set now
    alloc=""; zero="`seq 0 31`"
    _verify_l2_bitmap 0 "$alloc" "$zero"
    _verify_l2_bitmap 1 "$alloc" "$zero"
    # Now deallocate half of the subclusters of the first cluster
    poke_file "$TEST_IMG" $(($l2_offset+8)) "\x00\x00"
    # Discard cluster #0 again to see how the zero bits have changed
    $QEMU_IO -c 'discard -q 0 64k' "$TEST_IMG"
    # And do a full discard of cluster #1 by shrinking and growing the image
    $QEMU_IMG resize --shrink "$TEST_IMG" 64k
    $QEMU_IMG resize "$TEST_IMG" 1M
    # A normal discard sets all 'zero' bits only if the image has a
    # backing file, otherwise it won't touch them.
    if [ "$use_backing_file" = "yes" ]; then
        alloc=""; zero="`seq 0 31`"
    else
        alloc=""; zero="`seq 0 15`"
    fi
    _verify_l2_bitmap 0 "$alloc" "$zero"
    # A full discard should clear the L2 entry completely
    alloc=""; zero=""
    _verify_l2_bitmap 1 "$alloc" "$zero"
done

# Test that corrupted L2 entries are detected in both read and write
# operations
for corruption_test_cmd in read write; do
    echo
    echo "### Corrupted L2 entries - $corruption_test_cmd test (allocated) ###"
    echo
    echo "# 'cluster is zero' bit set on the standard cluster descriptor"
    echo
    _make_test_img 1M
    $QEMU_IO -c 'write -q 0 2k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+7)) "\x01"
    alloc="0"; zero=""
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd 0 1k" "$TEST_IMG"

    echo
    echo "# Both 'subcluster is zero' and 'subcluster is allocated' bits set"
    echo
    _make_test_img 1M
    $QEMU_IO -c 'write -q 0 2k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+11)) "\x01"
    alloc="0"; zero="0"
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd 0 1k" "$TEST_IMG"

    echo
    echo "### Corrupted L2 entries - $corruption_test_cmd test (unallocated) ###"
    echo
    echo "# 'cluster is zero' bit set on the standard cluster descriptor"
    echo
    _make_test_img 1M
    # We want to corrupt the (empty) L2 entry from cluster #0,
    # but we write to #4 in order to initialize the L2 table first
    $QEMU_IO -c 'write -q 256k 1k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+7)) "\x01"
    alloc=""; zero=""
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd 0 1k" "$TEST_IMG"

    echo
    echo "# 'subcluster is allocated' bit set"
    echo
    _make_test_img 1M
    # We want to corrupt the (empty) L2 entry from cluster #0,
    # but we write to #4 in order to initialize the L2 table first
    $QEMU_IO -c 'write -q 256k 1k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+15)) "\x01"
    alloc="0"; zero=""
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd 0 1k" "$TEST_IMG"

    echo
    echo "# Both 'subcluster is zero' and 'subcluster is allocated' bits set"
    echo
    _make_test_img 1M
    # We want to corrupt the (empty) L2 entry from cluster #0,
    # but we write to #4 in order to initialize the L2 table first
    $QEMU_IO -c 'write -q 256k 1k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+8)) "\x00\x00\x00\x01\x00\x00\x00\x01"
    alloc="0"; zero="0"
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd 0 1k" "$TEST_IMG"

    echo
    echo "### Compressed cluster with subcluster bitmap != 0 - $corruption_test_cmd test ###"
    echo
    # We actually don't consider this a corrupted image.
    # The bitmap in compressed clusters is unused so QEMU should just ignore it.
    _make_test_img 1M
    $QEMU_IO -c 'write -q -P 11 -c 0 64k' "$TEST_IMG"
    poke_file "$TEST_IMG" $(($l2_offset+11)) "\x01\x01"
    alloc="24"; zero="0"
    _verify_l2_bitmap 0 "$alloc" "$zero"
    $QEMU_IO -c "$corruption_test_cmd -P 11 0 64k" "$TEST_IMG" | _filter_qemu_io
done

echo
echo "### Image creation options ###"
echo
echo "# cluster_size < 16k"
IMGOPTS="extended_l2=on,cluster_size=8k" _make_test_img 1M

echo "# backing file and preallocation=metadata"
IMGOPTS="extended_l2=on,preallocation=metadata" _make_test_img -b "$TEST_IMG.backing" 1M

echo "# backing file and preallocation=falloc"
IMGOPTS="extended_l2=on,preallocation=falloc" _make_test_img -b "$TEST_IMG.backing" 1M

echo "# backing file and preallocation=full"
IMGOPTS="extended_l2=on,preallocation=full" _make_test_img -b "$TEST_IMG.backing" 1M

echo
echo "### qemu-img measure ###"
echo
echo "# 512MB, extended_l2=off" # This needs one L2 table
$QEMU_IMG measure --size 512M -O qcow2 -o extended_l2=off
echo "# 512MB, extended_l2=on"  # This needs two L2 tables
$QEMU_IMG measure --size 512M -O qcow2 -o extended_l2=on

echo "# 16K clusters, 64GB, extended_l2=off" # This needs one L1 table
$QEMU_IMG measure --size 64G -O qcow2 -o cluster_size=16k,extended_l2=off
echo "# 16K clusters, 64GB, extended_l2=on"  # This needs two L2 tables
$QEMU_IMG measure --size 64G -O qcow2 -o cluster_size=16k,extended_l2=on

echo "# 8k clusters" # This should fail
$QEMU_IMG measure --size 1M -O qcow2 -o cluster_size=8k,extended_l2=on

echo "# 1024 TB" # Maximum allowed size with extended_l2=on and 64K clusters
$QEMU_IMG measure --size 1024T -O qcow2 -o extended_l2=on
echo "# 1025 TB" # This should fail
$QEMU_IMG measure --size 1025T -O qcow2 -o extended_l2=on

# success, all done
echo "*** done"
rm -f $seq.full
status=0

